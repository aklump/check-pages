var tipuesearch = {"pages":[{"title":"Changelog","text":"  All notable changes to this project will be documented in this file.  The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.  [0.17] - 2022-11-27  Added  Changed   TEST_FINISHED changed to REQUEST_TEST_FINISHED TEST_FINISHED now is for \\AKlump\\CheckPages\\Event\\TestEventInterface   Deprecated   lorem   Removed   lorem   Fixed   lorem   Security   lorem   [0.16.0] - TBD  Deprecated   Runner::getRunner Runner::setRunner with_extras()   Changed   end loop is end_loop the drupal mixin no longer sets variables with user. as the base prefix, but instead uses the passed value of user, e.g. user: foo sets: foo.id, etc. The mixin config var has changed to $mixin_config instead of $config. add_shorthand() callback arguments changed to ($shorthand, Test). Also you will no longer unset() the shorthand key because it's been removed from the test config. Event::TEST_FINISHED has changed from \\AKlump\\CheckPages\\Event\\DriverEventInterface to \\AKlump\\CheckPages\\Event\\TestEventInterface. Changed is\/set to value\/set; replace is: with value:. See value plugin for details. request.method is now required; previously it could be omitted and would be assumed GET. Renamed data plugin to path plugin. Swithed to Symfony console. .\/check_pages became .\/check_pages run (added run as a required argument). BREAKING CHANGE! drupal8 and drupal7 mixins changed to a single drupal. BREAKING CHANGE! You must use $config instead of the like-named variable for mixin configuration. E.g. $drupal8, $drupal7 are now both just $config. BREAKING CHANGE! Rename global $app to $runner. BREAKING CHANGE! The style plugin now uses this format; (you must replace style with dom and property with style). yaml - dom: .visible style: display ... If expect is not explicitly provided, any value from 200 to 299 will pass the test. Previously the response code would have to be exactly 200 to pass.   Added   The concept of groups. The group (--group, -g) filter The import feature. The authentication for Drupal now adds the following variables automatically: ${user.uid}, ${user.id}, ${user.name}, ${user.pass} for the authenticated user. That means you can use these in subsequent tests, even if not authenticating said test. --request and --response. Request headers and body to display with --request or --show-source. If you do not want to see request and ONLY response, use --response instead of --show-source. --help and -h to printout CLI options. A debug message if test is missing assertions. Start and stop date and times. --filter now accepts multiple suites as CSV, e.g. --filter=foo,bar as well as single suites. The ability to test data-serving URLs (i.e. API endpoints) using JSON Schema.   Fixed   --quite mode was not working.   [0.15.0] - 2021-07-16  Added   config_get()   [0.14.0] - 2021-07-16  Added   The ability to omit config\/ in the CLI. Where before you had to pass --config=config\/live, which still works, you may also pass --config=live if your configuration directory is named by the standard name of config. If it is not then this shortcut will fail.   [0.13.0] - 2021-07-07  Added   Output file urls.txt Output file failures.txt   [0.12.0] - 2021-07-06  Added   why key for message overrides. Disk storage of sessions storage across runners. See docs for more info.   [0.11.0] - 2021-07-03  Added   Create tests directory prompt on package install. Authentication for Drupal 7 and Drupal 8 via with_extras() function. add_test_option() function for custom functionality.   Removed   composer create-project is no longer supported as it was too confusing and unnecessary to have two installation means.   [0.10.0] - 2021-05-28  Added   is not not matches   Changed   exact is now is; change all usages. match is now matches; change all usages. none is now not contains; change all usages.   Removed   exact match none   Fixed   JS error when the eval is used more than once per test.   [0.9.0] - 2021-05-28  Added   The header assertion plugin   [0.8.0] - 2021-04-14  Added   The javascript selector for expression evaluation.   Changed   It's no longer required to add js: true to a test implementing a style selector. It will now be forcefully set (or overridden) to true. This is because the style selector only works when javascript is enabled.   [0.7.0] - 2021-04-08  Added   Added the none assertion to ensure a substring does not appear on the page.   [0.6.0] - 2021-01-16  Added   Added new selector 'attribute'. Added ability to do style asserts. Added globbing to run_suite(), e.g. run_suite('*') to run all suites. Normal glob patterns work as well, which are relative to the --dir directory, or defaults to the directory containing runner.php.   Changed   run_suite() now returns void().   [0.5.1] - 2021-01-14  Added   The alias visit: may be used instead of url: Examples now show using visit:, though url: still works.   [0.5] - 2021-12-30  Added   --filter parameter to limit runner to a single suite from the CLI.   [0.4] - 2020-12-01  Added   Javascript support with Chrome.   Changed   The way the CSS selector works has changed fundamentally and may break your tests. Refer to the following test YAML. Prior to 0.4 that would only choose the first .card__title on the page and assert it's text matched the expected. Starting in 0.4, all .card__titles found on the page will be matched and the assert will pass if any of them have matching text.  -   visit: \/foo\/bar   find:     -       dom: .card__title       text: The Top of the Mountain  If you need the earlier functionality you should use the xpath selector as shown here to indicate just the first element with that class.  -  visit: \/foo\/bar  find:    -      xpath: '(\/\/*[contains(@class, \"card__title\")])[1]'      text: The Top of the Mountain    [0.3] - 2020-08-15  Added   Added the --quiet flag   Changed   The default output is now how it was when adding the --debug flag, use the --quiet flag for less verbosity. Visual layout to make reading results easier and more clear.   Removed   The --debug flag  ","tags":"","url":"CHANGELOG.html"},{"title":"Check Pages","text":"  Very Simple QA for HTTP    Summary  This project intends to provide a process of QA testing of a website, which is very fast to implement and simple to maintain. You write your tests using YAML and they can be as simple as checking for a 200 HTTP response on the homepage.  -   visit: \/   Or ensuring the admin section is protected.  -   visit: \/admin   why: Make sure the `\/admin` path returns 403 forbidden when not logged in.   expect: 403   In a third test we can assert there is one logo image on the homepage, like so:  - visit: \/   find:     - dom: '#logo img'       count: 1   Lastly, make sure there are no unprocessed tokens on the page (a.k.a. a substring does not appear):  - visit: \/   find:     - not contains: '[site:name]'   For more code examples explore the \/examples directory.  Visit https:\/\/aklump.github.io\/check_pages for full documentation.  Clarity of Purpose and Limitation  The mission of this tool is to provide testing for URLS and webpages in the most simple and concise syntax possible. For testing scenarios that require element interaction, such as clicks, hovers, scrolling, etc, there are amazing projects out there such as Cypress. This project will never try to compete with that crowd, and shall always restrict it's testing of the DOM to assertions against a single snapshot of the loaded URL.  Terms Used   Test Runner - A very simple PHP file that defines the configuration and what test suites to run, and in what order. @see includes\/runner.php. Test Suite - A YAML file that includes one or more checks against URLs. @see includes\/suite.yml. Test - A single URL check within a suite. Assertion - A single check action against the HTTP response of a test, i.e., headers, body, status code, javascript, etc.   Requirements   You must install with Composer. Tests suites are written in YAML. Little to no experience with PHP is necessary. Copy and paste will suffice.   Install  $ composer require aklump\/check-pages --dev    In most cases the --dev is appropriate, but use your own discretion. You will be asked if you want to create a directory for your tests when you install. This will copy over a basic scaffolding to build from.1 More detailed examples are located in the example directory.   1Creating Test Directories At Any Time  Use .\/create_test_directory outside of installation to copy scaffolding.  Example Tests Demo  If you are new to this project and would like to see a demonstration, it would be a good idea to start with the examples. Run the example tests with the following commands. Then open up the files in the example\/tests directory and study them to see how they work.1   Open a new shell window which will run the PHP server for our example test pages.  $ .\/bin\/start_test_server.sh  Open a second shell window to execute the tests.  $ .\/bin\/run_tests.sh    Some failing tests are also available to explore:  $ .\/check_pages failing_tests_runner.php   1 If you see no tests directory then create one and copy the contents of examples into tests. The example tests directory will only be created if you use create-project as the installation method.  Writing Your First Test Suite  If you created a test directory on install then you're ready to build on that. If you did not you can do that now by running the script in vendor\/bin\/check_pages_init  Multiple Configuration Files  The project is designed to be able to run the same tests using different configurations. You can create multiple configuration files so that you are able to run the same test on live and then on dev, which have different base URLs.  . \u2514\u2500\u2500 tests     \u251c\u2500\u2500 config\/dev.yml     \u251c\u2500\u2500 config\/live.yml     \u251c\u2500\u2500 suite.yml     \u2514\u2500\u2500 runner.php   In runner.php use the following line to specify the default config file:  load_config('config\/dev');   When you're ready to run this using the live config add the config filename to the CLI command, e.g.,  $ .\/check_pages runner.php --config=config\/live   Test functions  The test functions for your PHP test files are found in includes\/runner_functions.inc.  Is JS Supported?  Yes, not by default, but you are able to indicate that given tests requires Javascript be run. Read on...  Javascript Testing Requirements   Your testing machine must have Chrome installed.   Javascript Testing Setup  To support JS testing, you must indicate where your Chrome binary is located in your runner configuration file, like so:  chrome: \/Applications\/Google Chrome.app\/Contents\/MacOS\/Google Chrome   Enable Javascript per Test  Unless you enable it, or in the case the selector type (i.e., style , javascript) requires it, javascript is not run during testing. If you need to assert that an element exists, which was created from Javascript (or otherwise need javascript to run on the page), you will need to indicate the following in your test, namely js: true.  -   visit: \/foo   js: true   find:     -       dom: .js-created-page-title       text: Javascript added me to the DOM!   Asserting Javascript Evaluations  Let's say you want to assert the value of the URL fragment. You can do that with the javascript selector. The value of javascript should be the expression to evaluate, once the page loads. Notice that you may omit the js: true as it will be set automatically.  -   visit: \/foo   find:     -       javascript: location.hash       is: \"#top\"   Javascript Testing Related Links   Chrome DevTools Protocol 1.3 Learn more CLI parameters More on parameters https:\/\/github.com\/GoogleChrome\/chrome-launcher https:\/\/peter.sh\/experiments\/chromium-command-line-switches\/ https:\/\/raw.githubusercontent.com\/GoogleChrome\/chrome-launcher\/v0.8.0\/scripts\/download-chrome.sh   Filter  Use the --filter parameter combined with a suite name to limit the runner to a single suite. This is faster than editing your runner file.  .\/check_pages runner.php --filter=page_header   Or the shorthand  .\/check_pages runner.php -f page_header   Combine more than one filter value for an OR selection  .\/check_pages runner.php -f page_header -f rss   Troubleshooting  Try using the --response to see the response source code as well.  .\/check_pages failing_tests_runner.php --response   Usage  In this case, since the project will be buried in your vendor directory, you will need to provide the directory path to your test files, when you run the test script, like this:  .\/vendor\/bin\/check_pages runner.php --dir=.\/tests_check_pages   This example assumes a file structure like this:  . \u251c\u2500\u2500 tests_check_pages \u2502\u00a0\u00a0 \u2514\u2500\u2500 runner.php \u2514\u2500\u2500 vendor     \u2514\u2500\u2500 bin         \u2514\u2500\u2500 check_pages     Contributing  If you find this project useful... please consider making a donation. ","tags":"","url":"README.html"},{"title":"Authentication","text":"  If you want to check pages as an authenticated user of a website, then you have to be logged in, or authenticated before the request is made. Some authentication providers are built-in, or you can write your own using  add_test_option(). You might refer to includes\/drupal8.inc as a starting point.  Basic Setup  This example will use the drupal8 built-in authentication provider. Note: for Drupal 7 authentication, simply change add_mixin('drupal8'... to add_mixin('drupal7'....   Create a YAML (or JSON) file containing user login credentials.  Do not commit this to source control. You can place this whereever, but in this example it will be located in the config directory as config\/users.yml. You may list as many users as you want. Each record must have the keys name and pass. Yes, pass is the un-hashed plaintext password for the user, so be cautious.  # File: config\/users.yml -   name: admin   pass: 123pass -   name: member   pass: secret5  Add the following to your test runner file. This tells your runner.php to include the Drupal 8 authentication and from where to pull the user data.  # File: runner.php add_mixin('drupal8', [   'users' =&gt; 'config\/users.yml', ]);   In your test suite add the user option to a test, giving the username as the value. The request for that test will be made after first authenticating that user.  # File: suite.yml -  user: admin  visit: \/admin -  user: member  visit: \/admin  expect: 403     Variations on the Above   If the login form is located at a non-standard URL, you may indicate that URL, which renders the login form, as shown here.  add_mixin('drupal8', [   'users' =&gt; 'config\/users.yml',   'login_url' =&gt; '\/login', ]);   It's also worth nothing, once a user is authenticated, certain variables may be used on subsequenst tests. Notice how the variables persist into the second test even though it is not authenticated. The user variables will carry over into subsequent tests until the next authentication, when they will be re-set.  - user: testbot.member visit: \/user\/${user.uid}\/edit - visit: \/user\/${user.uid}\/edit expect: 403 - visit: \/user\/${user.name} expect: 200  It's possible you don't want to use the same users.yml data file for all configurations. To accommodate this you may replace the hardcoded path config\/users.yml with config_get('extras.users') and add the hard-coded path to each of your configuration files.  # file: runner.php add_mixin('drupal8', [  'users' =&gt; config_get('extras.users'), ]);    # file: config\/live.yml ... extras:  users: config\/users--live.yml   # file: config\/dev.yml ... extras:  users: config\/users--dev.yml  You can capture several user IDs at once like this. Furthermore, this can be moved to an import, and you have all user IDs available to all suites, very easily by importing with - import: imports\/get_user_ids  See imports for more info.  # file: imports\/_get_user_ids  -  user: site_test.worker  set: workerUid  is: ${user.id} -  user: site_test.admin  set: adminUid  is: ${user.id}    CSRF Tokens  The token ${user.csrf} is created automatically when you use user, and can be used as shown below:  -   user: site_test.admin   url: \/cp-api\/${cp_api_public}\/jobs   request:     method: POST     headers:       X-Csrf-token: ${user.csrf}  ","tags":"","url":"authentication.html"},{"title":"Getting Started","text":"  Does a Page Load?  -   visit: \/foo   Is the Status Code Correct?  By saying that the \"page loads\", we mean that it returns a status code of 200. The following is exactly the same in function as the previous example. You can assert any HTTP status code by changing the value of expect.  -   visit: \/foo   expect: 200   Is an URL Redirecting As Expected?  For pages that redirect you can check for both the status code and the final location.  (redirect and location may be used interchangeably.)  -   visit: \/moved.php   expect: 301   location: \/location.html  -   visit: \/moved.php   expect: 301   redirect: \/location.html   Does the Page Have Certain Content?  Once loaded you can also look for things on the page with find. The most simple find assertion looks for a substring of text anywhere on the page. The following two examples are identical assertions.  -   visit: \/foo   find:     - Upcoming Events Calendar   -   visit: \/foo   find:     -       contains: Upcoming Events Calendar   Ensure something does NOT appear on the page like this:  -   visit: \/foo   find:     -       not contains: \"[token:123]\"  ","tags":"","url":"cheatsheet.html"},{"title":"Command Line Runner","text":"  Filter  Use the --filter parameter combined with a suite name to limit the runner to a single suite. This is faster than editing your runner file.  .\/check_pages runner.php --filter=page_header   Or the shorthand  .\/check_pages runner.php -f page_header   Combine more than one filter value for an OR selection  .\/check_pages runner.php -f page_header -f rss   Troubleshooting  Try using the --response to see the response source code as well.  .\/check_pages failing_tests_runner.php --response  ","tags":"","url":"cli.html"},{"title":"Ignore Suites","text":"   Config items take this form suite or group\/suite.  ","tags":"","url":"config--suites_to_ignore.html"},{"title":"How To Use A Custom Directory For Suite Files","text":"  You may locate suite files in directories other than the main one, by registering those directories with the add_directory() function. After that run_suite() will also look for suite names in the added directory(ies).  &lt;?php \/**  * @file  * Assert URLs as an anonymous user.  *\/ load_config('config\/dev.yml'); add_directory(realpath(__DIR__ . '\/..\/web\/themes\/custom\/gop_theme\/components\/smodal'));  run_suite('*');  \/\/ Glob doesn't yet work with add_directory(), so you have to list the suite \/\/ explicitly like this: run_suite('smodal');   ","tags":"","url":"deep--custom_dirs.html"},{"title":"Setup Before Test","text":"  Some integration testing requires that an environment exist in a given state before the tests can run. How can you ensure that the website is in that state before your test suite begins?  Server-Side Setup  In this strategy, you setup an endpoint that receives an ID representing a state. You then write server-side code to put your website into that state when it receives a request. How you write the server-side is up to you, and depends on the language, framework, etc. All you do on the Check Pages side of things is make a request to that appropriate endpoint at the beginning of your suite:  # file: suite.yml -   visit: \/test-set-state.php?state=foo   ...   ","tags":"","url":"deep--setup.html"},{"title":"Variables","text":"   The user ID of the authenticated user is available to your suite as ${id}. You can capture the value of h1 into a variable as ${title} and used in a subsequent test. With javascript you can read the url into ${url} and assert against it.   All of these are examples of variables.  Sharing Values Between Tests  You create variables like this:  -   set: title   value: 'Lorem Ipsum'   Which can be used like this:  -   set: title   value: 'Lorem Ipsum' -   visit: \/foo.html   find:     -       dom: h1       is: ${title}   Note: Interpolation will only occur if the variable exists. That means that in the following example, the second assert will assert against the literal value ${other}.  -   set: title   value: 'Lorem Ipsum' -   visit: \/foo.html   find:     -       dom: h1       is: ${title}     -       dom: h2       is: ${other}   Using Response Values  In this example we'll GET a resource ID and store it using set, then DELETE it in a subsequent test using interpolation.  -   visit: \/api\/2\/foo   find:     -       node: collection.items.data.0.id       set: fooId  -   url: \/api\/2\/foo\/${fooId}   request:     method: delete   expect: 204   Scope  Variables used this way are scoped to the suite. They can be shared across tests and assertions, but not across suites.  Variable Re-Assignment  The authentication plugin will create ${user.uid}, however it will be overwritten on the next authentication. To capture and reassign to a different variable name do like the following:  -   why: Capture UID from session for reassignment   user: foo_user   visit: \/  -   why: Reassign to authenticated user ID to variable fooUserId   set: fooUserId   value: ${user.uid}  -   why: Assert the title of Foo's user page is correct.   visit: \/user\/${fooUserId}   find:     -       dom: h1       text: Foo User  ","tags":"","url":"deep--variables.html"},{"title":"Breakpoint","text":"  Provides a means of stopping a suite until a key is pressed. Use this like you would a debugging breakpoint when writing tests if you need to examine server state, for example.  Any key will go on to the next test, however CTRL-C will exit the suite as you might expect.  Breakpoints are only active in debug mode (-vvv), e.g.,  .\/vendor\/bin\/check_pages run tests\/runner.php -vvv  Example Tests  -   why: Demonstrate the Breakpoint plugin syntax.   url: \/test_subject.html -   why: Stop test execution until user presses a key.   breakpoint: -   why: Show the test continues after breakpoint.   url: \/test_subject.html    Provided by the breakpoint plugin. ","tags":"","url":"demo--breakpoint.html"},{"title":"Count Plugin","text":"  This plugin is unique in that it provides no find schema. It relies on other plugins to add count to their find schemas.  This uses The Symfony Expression Language under the hood.  Example Tests  -   why: Demonstrate the Count plugin syntax.   url: \/test_subject.html   find:     -       dom: h1       count: 1     -       dom: h1       count: \"!= 16\"     -       xpath: \/\/h1       count: \"1\"     -       dom: h1       count: \"&lt;2\"     -       dom: h1       count: \"&lt; 2\"     -       dom: h5       count: 0     -       dom: li       count: \"&gt;=5\"     -       dom: li       count: \"&gt;= 5\"     -       dom: li.emotion       count: 2     -       dom: li       text: Fear       count: 1     -       dom: li       text: Morning       count: 0     -       dom: '.sidebar a'       attribute: href       matches: \/^\\\/story\/       count: \"&gt;=2\"  -   value: 5   set: maxItems -   value: 4   set: itemCount -   why: Demonstrate the Count plugin with interpolation.   url: \/test_subject.html   find:     -       dom: h1       count: ${maxItems} - ${itemCount}    Provided by the count plugin. ","tags":"","url":"demo--count.html"},{"title":"Cypress","text":"  Provides a wrapper around Cypress to incorporate Cypress testing from within Check Pages. Allows passing of Check Pages variables to Cypress for passing of context.  Configuration  extras:   cypress:     cypress: \/Users\/aklump\/Code\/Projects\/ContechServices\/AuroraTimesheet\/site\/app\/node_modules\/.bin\/cypress     config_file: \/Users\/aklump\/Code\/Projects\/ContechServices\/AuroraTimesheet\/site\/app\/cypress\/config\/dev.config.js     spec_base: \/Users\/aklump\/Code\/Projects\/ContechServices\/AuroraTimesheet\/site\/app\/cypress\/e2e\/    suite.yml Example  -   set: timesheet.id   value: 240 -   set: timesheet.worker.id   value: 160 -   why: Demonstrate the Cypress Plugin syntax.   cypress: worker\/3632.cy.js   env:     user: site_test.worker1     visit: node\/${timesheet.id}\/approve\/${timesheet.worker.id}    Todo   debug output update title correctly implement https:\/\/docs.cypress.io\/guides\/guides\/command-line#Debugging-commands   Example Tests  Provided by the cypress plugin. ","tags":"","url":"demo--cypress.html"},{"title":"Dom","text":"  Example Tests  -   visit: \/test_subject.php   find:     -       dom: nav a       attribute: href       is: \/page2       set: url      -       eval: '\"\/page2\" == \"${url}\"'     -       dom: nav a[href=\"${url}\"]       text: Page 2      -       why: Make sure no forms appear on the homepage.       dom: form       count: 0      -       dom: '.block-title'       text: Latest Blog Post       count: 1      -       dom: '.block-title'       text: Not on the Page       count: 0      -       dom: '#logo'       attribute: title       is: An SVG image     -       why: Find an anchor tag with an href ending in something.       dom: a       attribute: href       matches: \/\\\/bar?\/     -       dom: p       count: \"&gt;= 2\"     -       dom: p       count: \"&lt; 2000\"      -       why: Assertions in the DOM using CSS selectors.       dom: '#logo svg'       count: 1      -       why: Notice the use or `text` vs. `is` for accessing the contents of a DOM find as either plaintext or markup respectively.       dom: h1.page-title       text: About In the Loft Studios      -       dom: h1.page-title       is: '&lt;span&gt;About In the Loft Studios&lt;\/span&gt;'      -       dom: h1.page-title       set: pageTitle      -       dom: h1.page-title       is not: '&lt;div&gt;About In the Loft Studios&lt;\/div&gt;'      -       why: Case-insensitive RegEx match against the markup of #footer.       dom: '#footer'       matches: '\/in the loft studios\/i'      -       why: Showing how to check the hero alt tag two different ways.       dom: '[title=\"An SVG image\"]'       count: 1      -       dom: '.block-title'       text: Quick Start      -       dom: '.block-title'       text: Upcoming Events       -       dom: '#footer #copyright'       count: 1     -       why: Capture the timestamp to use in the next assertion.       dom: .page-title       attribute: data-timestamp       matches: \/.+\/       set: currentTime     -       why: Assert the timestamp in the data attribute matches the subtitle; because the value is dynamic and always changing, the only way to assert against it is to use the set property.       dom: h2.page-subtitle       matches: \/${currentTime}$\/     -       why: Assert using set with matches, sets the matched value, not the original.       dom: .progress       matches: \/^\\d+\/       set: percentage -   eval: ${percentage} == 89    Provided by the dom plugin. ","tags":"","url":"demo--dom.html"},{"title":"Evaluate","text":"  Allows runtime evaluation such as comparing values captured using set.  https:\/\/symfony.com\/doc\/current\/components\/expression_language.html     You may need to wrap some values in quotes, e.g. \"2022-09-07T20:04:04+0000\" &lt; \"2022-09-07T20:04:06+0000\".   Example Tests  # This test also tests to make sure that variables can be reassigned across tests. -   why: Demonstrate how to assert an image's aspect ratio using `eval`.   visit: \/test_subject.html   find:     -       dom: img.tree       style: width       set: width     -       dom: img.tree       style: height       set: height     -       why: Assert image has a landscape aspect ratio.       eval: ${height} &lt; ${width} -   why: Assert a different image this time.   visit: \/test_subject.html   find:     -       dom: img.lake       style: width       set: width     -       dom: img.lake       style: height       set: height     -       why: Assert image has a tall aspect ratio.       eval: ${height} &gt; ${width} -   why: Demonstrate eval at the test level   eval: ${height} &gt; ${width}     Provided by the evaluate plugin. ","tags":"","url":"demo--evaluate.html"},{"title":"Testing Forms","text":"  The form plugin allows you to test the submission of forms.  Submit  The submit is a special dom selector in that it uses the form as the root, so you can only select elements inside the form AND you should omit any reference to the form element, as it will be prepended automatically.  You only need to use this if the form contains more than one input[type=\"submit\"] element.  Setting Form Values  To provide a form value, add an object to the input array as shown below. It must have the keys name and value, where name is thename` attribute of the form element.  Dates   You must wrap date strings in quotations like this value: \"2010-01-01\".   Select   Instead of using value, you may use option to set the value of a &lt;select&gt; element. It is case-sensitive. Subject to the Element Present limitation.   Element Present limitation  The DOM element must be present in the markup and not added via AJAX, if it's not present the value cannot be determined.  Example Tests  -   why: An example to load the page and submit the form.   url: \/test_subject.php   form:     dom: .form-a   find:     -       dom: .messages       text: Form A Was Submitted  -   why: Demonstrate using the \"submit\" to indicate which of several submit buttons.   url: \/test_subject.php   form:     dom: .form-b     submit: '.form-save'   find:     -       dom: .messages       text: Save Was Used to Submit  -   why: Demonstrate using the \"submit\" again, with a different button.   url: \/test_subject.php   form:     dom: .form-b     submit: '.form-delete'   find:     -       dom: .messages       text: Delete Was Used to Submit  -   why: Demonstrate submitting values to the form.   url: \/test_subject.php   form:     dom: .form-b     input:       -         name: message         value: A Little Extra Message       -         why: This is not in the form, but it can still be provided without a test error.         name: first_name         value: Frank   find:     -       dom: .messages       text: A Little Extra Message  -   why: Demonstrate submitting values to the form using an import.   url: \/test_subject.php   form:     dom: .form-b     input:       -         import: imports\/form_data     find:       -         dom: .messages         text: A Little Extra Message  -   why: Demonstrate a form that has an action to another URL.   url: \/test_subject.php   form:     dom: .form-c     input:       -         name: first_name         value: Rachel       -         name: date         value: \"2010-01-01\"   find:     -       dom: h1       text: Thank you Rachel, for your submission     -       dom: h2       text: Your membership will begin on 2010-01-01. -   set: savedFirstName   value: Anne -   set: savedDate   value: \"1982-06-30\" -   why: Assert interpolation works for input values.   url: \/test_subject.php   form:     dom: .form-c     input:       -         name: first_name         value: ${savedFirstName}       -         name: date         value: \"${savedDate}\"       -         name: shirt_size         option: small   find:     -       dom: h1       text: Thank you Anne, for your submission     -       dom: h2       text: Your membership will begin on 1982-06-30.     -       dom: p       text: Your shirt size is sm.  -   why: Demonstrate textfield default value is submitted.   url: \/test_subject.php   form:     dom: .drupal-form   find:     -       dom: .messages       is: $5.99  -   why: Demonstrate how a Drupal form can be submitted w\/hidden fields.   url: \/test_subject.php   form:     dom: .drupal-form     input:       -         name: field_amount[0][value]         value: $19.99      # This is optional, but may help with readability.     submit: '#edit-submit'    find:     -       why: Assert the new value $19.99 is received by the form handler.       dom: .messages       is: $19.99    Provided by the form plugin. ","tags":"","url":"demo--form.html"},{"title":"Testing Response Headers","text":"  You can assert against response headers like this:  -   visit: \/foo   find:     -       header: content-type       contains: text\/html     header is NOT case-sensitive. But contains is, so... if you're trying to match a header value with case-insensitivity, you should use the match key, with the i flag like this:  - header: content-type   matches: \/text\\\/html\/i    Example Tests  -   visit: \/test_subject.php   find:     -       header: foo       set: fooHeader     -       header: foo       is not: pha     -       header: foo       contains: pha     -       header: foo       is: alpha     -       header: bar       is: BRAVO     -       header: bar       matches: \/^bravo$\/i     -       header: bar       not matches: \/^charlie$\/i     -       why: This header should not even exist, testing that case.       header: zulu       not matches: \/^charlie$\/i     -       header: baz       count: 0     -       header: content-type       count: 1    Provided by the header plugin. ","tags":"","url":"demo--header.html"},{"title":"Imports (Code Reuse with Partials)","text":"  How it Looks  # file: suite.yml  # Here is an example of a test import -   import: imports\/headings  # Here is an example of an assertion import -   visit: \/foo.html   find:     -       import: imports\/find\/sections      Imports can only be configured via interpolation (see below). Other configurable options for reusable code to consider are: shorthand, options or plugins.   Explained  The concept of imports is not new. Write a partial and include it in other files. You can do this too with Check Pages.  If you write five suites and realize that you repeat the same tests in several, this is a time to consider an import. It creates coupling and dependency, so it may or may not be a good idea.  What used to look like this, repeated in several suites:  # files: suite.yml, suite2.yml, suite3.yml, ...  -   visit: \/   find:     -       dom: h1       set: title -   visit: \/contact   find:     -       dom: h1       set: contactTitle -   visit: ...   Can be moved to a file called imports\/_headings.yml and those repeated sections in your suite files can be replaced with an import, like this:  # files: suite.yml, suite2.yml, suite3.yml, ...  -   import: imports\/headings -   visit: ...   Key Points   Where you save import files is up to you, imports directory is given as an example. The value of import must be a resolvable path. The leading underscore is optional, and like SASS partials it is ignored by the parser. You may use it or not, that is to say &#95;headings.yml and headings.yml are seen as the same import file. The extension is optional and when excluded, is assumed as .yml. A single import line in your test (one YAML array element) maps to one or many tests in the import file. That is to say, a single import can include one test, or several tests. If you use why as a sibling to import, that is only for your test reading, it will not be printed when the test is run. So think of it as answering the question of \"Why use this import?\", if you use it. You may use an import to substitute tests or assertions; see the examples below. It's good practice to put your find imports in a subfolder find as it's easier to reason about. Imports cannot recursively import other imports at this time.   Configure Imports with Interpolation  # file: suite.yml -   why: Set `id` which is used in our import file to build the URL.   set: baz   is: 123  -   import: imports\/setup_timesheet   # file: imports\/_setup_timesheet.yml -   url: \/foo\/bar\/${baz}   Usage by Other Plugins  Use this pattern in other plugins to implement imports.  $importer = new \\AKlump\\CheckPages\\Plugin\\Importer($test-&gt;getRunner()); $importer-&gt;resolveImports($config['form']['input']);   In this example the form plugin allows the usage of imports, e.g.,  -   url: \/form.html   form:     dom: form     input:       -         import: imports\/form_data   Example Tests  -   why: Create a variable to ensure import interpolation is handled correctly.   value: Imports   set: headingControlValue -   import: imports\/headings   why: Test the basic syntax of an import. -   import: imports\/_headings   why: Assert underscore and no extension works. -   import: imports\/links.yml   why: Assert extension behaves. -   import: imports\/_links.yml   why: Verify the underscore works. -   visit: \/test_subject.html   find:     -       why: Assert button is present       dom: button       text: alpha     -       why: Assert button is present using xpath       xpath: \/\/button       count: 1     -       why: Repeat the above using an assertion import.       import: imports\/find\/button     -       value: alpha       set: control.alpha -   why: Test import interpolation when value is set as assertion in earlier test.   import: imports\/interpolate    Provided by the import plugin. ","tags":"","url":"demo--import.html"},{"title":"Testing with Javascript","text":"  You can use javascript in your tests to capture things like the window location or query string. The test is run inside of Chrome devtools so the full javascript console is available.  Extract an ID from an URL and Reuse it  -   visit: \/node\/25029   find:     -       javascript: location.pathname.split('\/')[2]       set: nid  -   visit: \/print\/node\/{nid}   Assert the URL Hash Matches RegEx Pattern  -   visit: \/   find:     -       javascript: location.hash       matches: \/^#foo=bar&amp;alpha=bravo$\/   Example Tests  -   why: Assert javascript is run after the redirect.   visit: \/test_subject.php?redirect   expect: 302   find:     -       javascript: location.search       is: ?redirected  -   visit: \/test_subject.php   js: true   find:     -       why: Test we can eval JS without asserting anything.       javascript: document.querySelector('body').classList.add('foo')     -       why: This content is generated by JS in test_subject.php.  It will only be there if the test is run with JS turned on.       dom: h1       text: COVID 19 Pandemic     -       why: Assert we can set the results of a javascript evaluation.       javascript: location.pathname       set: path  -   why: This example shows how to check the window location hash by using the javascript selector.  It also checks that js is set to true automatically.   visit: \/test_subject.php   find:     -       javascript: location.hash       matches: \/^#foo=bar&amp;alpha=bravo$\/     -       javascript: location.hash       is: '#foo=bar&amp;alpha=bravo'     -       javascript: location.hash       is not: '#foo=bar&amp;alpha=bravo&amp;charlie=delta'     -       javascript: location.query       is: \"\"    Provided by the javascript plugin. ","tags":"","url":"demo--javascript.html"},{"title":"More Javascript","text":"  Javascript Testing Requirements   Your testing machine must have Chrome installed.   Javascript Testing Setup  To support JS testing, you must indicate where your Chrome binary is located in your runner configuration file, like so:  chrome: \/Applications\/Google Chrome.app\/Contents\/MacOS\/Google Chrome   Enable Javascript per Test  Unless you enable it, or in the case the selector type (i.e., style , javascript) requires it, javascript is not run during testing. If you need to assert that an element exists, which was created from Javascript (or otherwise need javascript to run on the page), you will need to indicate the following in your test, namely js: true.  -   visit: \/foo   js: true   find:     -       dom: .js-created-page-title       text: Javascript added me to the DOM!   Asserting Javascript Evaluations  Let's say you want to assert the value of the URL fragment. You can do that with the javascript selector. The value of javascript should be the expression to evaluate, once the page loads. Notice that you may omit the js: true as it will be set automatically.  -   visit: \/foo   find:     -       javascript: location.hash       is: \"#top\"   Javascript Testing Related Links   Chrome DevTools Protocol 1.3 Learn more CLI parameters More on parameters https:\/\/github.com\/GoogleChrome\/chrome-launcher https:\/\/peter.sh\/experiments\/chromium-command-line-switches\/ https:\/\/raw.githubusercontent.com\/GoogleChrome\/chrome-launcher\/v0.8.0\/scripts\/download-chrome.sh  ","tags":"","url":"demo--javascript2.html"},{"title":"Testing APIs with JSON Schema","text":"  You can test APIs using JSON Schema, here's the basic idea...  . \u251c\u2500\u2500 runner.php \u251c\u2500\u2500 schemas \u2502\u00a0\u00a0 \u2514\u2500\u2500 object.json \u2514\u2500\u2500 suite.yml    Create a JSON file with the JSON schema and save it somewhere, e.g. schemas\/object.json.  # file: object.json   {     \"type\": \"object\" }  Then write a test to use that schema:  # file: suite.yml -   visit: \/api\/2\/thing\/99   find:     -       schema: schemas\/object.json     -       schema: schemas\/array.json       matches: false  matches may also be false; it may be omitted and defaults to true. Notice the usage of a second schema to use as a NOT match, in this case schemas\/array.json. The content-type header will be used to decode the response body. schema should be resolvable filepath, or a JSON string representing a schema.   Testing Only a Portion of the Response  You may also apply a schema on just part of the reponse data using the path modifier.   Given the following response:  {   \"lorem\": {        \"ipsum\": [            {                \"dolar\": true            }        ]    } }  You can apply a schema to the array at ipsum. Provide the schema subject using dot notation as path, in this case lorem.ipsum. Also notice that schema can be a JSON string, and doesn't have to reference a filepath.  # file: suite.yml -  visit: \/api\/2\/thing\/99  find:    -      schema: '{\"type\":\"array\"}'      path: lorem.ipsum    Example Tests  -   why: Demo how document.json can use $ref and $def.   url: \/test_subject.json   find:     -       schema: schemas\/document.json -   url: \/test_subject.json   find:     -       schema: schemas\/is_object.json     -       schema: schemas\/is_array.json       matches: false  -   url: \/test_subject.json   find:     -       schema: schemas\/is_array.json       path: lorem.ipsum -   url: \/test_subject.json   find:     -       schema: '{\"type\":\"array\"}'       path: lorem.ipsum -   url: \/test_subject.json   find:     -       schema: schemas\/is_object.json       matches: true     -       schema: schemas\/is_foo.json       matches: true     -       schema: schemas\/is_array.json       matches: false    Provided by the json_schema plugin. ","tags":"","url":"demo--json_schema.html"},{"title":"Loops","text":"  Variables  The following loop variables are available. They are only available to be interpolated in tests within the loop.  Arrays   loop.length int The number of iterations. loop.last boolean true If the last item in the loop. loop.index int 1-based index loop.index0 int 0-based index loop.value mixed Current value   Maps\/Objects   loop.length loop.last loop.property loop.value   Example Tests  -   loop: 4x  -   why: $loop[${loop.index}] = ${loop.value}   set: value${loop.index}   value: ${loop.value}  -   end_loop:  -   loop: 2...4  -   why: $loop[${loop.index}] = ${loop.value}   visit: \/test_subject.html   find:     -       dom: h${loop.value}       count: ${loop.index}  -   end_loop:  -   loop:     h2: Lorem     h3: Ipsum     h4: Dolar -   why: $loop.${loop.property} = ${loop.value}   visit: \/test_subject.html   find:     -       dom: ${loop.property}       text: ${loop.value}  -   end_loop:  -   loop:     - blockquote     - p     - span -   why: Demonstrate loop array interpolation ($loop[${loop.index}] = ${loop.value})   visit: \/test_subject.html   find:     -       dom: ${loop.value}       count: ${loop.index0}  -   end_loop:  -   loop:     - [ 200, Welcome to the Loop Page ]     - [ 200, Lorem ]  -   why: 'Demonstrate loop array w\/arrays interpolation #${loop.index}.'   visit: \/test_subject.html   expect: ${loop.value[0]}   find:     -       why: Assert the page title is correct (using dot syntax).       dom: h${loop.index}       text: ${loop.value.1}  -   end_loop:  -   loop:     -       code: 200       title: Welcome to the Loop Page     -       code: 200       title: Lorem  -   why: 'Demonstrate loop array w\/objects interpolation #${loop.index}.'   visit: \/test_subject.html   expect: ${loop.value.code}   find:     -       why: Assert the page title is correct.       dom: h${loop.index}       text: ${loop.value.title}  -   end_loop:    Provided by the loop plugin. ","tags":"","url":"demo--loop.html"},{"title":"The Path Plugin is for Testing Structured Content","text":"  {     \"foo\": {         \"bar\": \"baz\"     } }   - visit: \/api\/thing.json   find:     - path: foo.bar       is: baz   In Depth  The plugin is able to access the values from JSON, XML and YAML responses. It uses the Content-type header to deserialize the request body. Given any of the following...  Content-type: application\/json  {\"foo\":{\"bar\":\"baz\"}}   Content-type: application\/xml  &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;foo&gt;   &lt;bar&gt;baz&lt;\/bar&gt; &lt;\/foo&gt;   Content-type: application\/x-yaml  foo:   bar: baz   ... the following test could be used.  - visit: \/api\/thing   find:     - path: foo       count: 1     - path: foo.bar       is: baz     - path: foo.bar       is not: yaz     - path: foo.bar       contains: az     - path: foo.bar       not contains: alpha     - path: foo.bar       matches: \/^baz$\/     - path: foo.bar       not matches: \/\\d+\/   Request Headers  request can be used to send headers, as in this case where we pass accept. Notice how we ensure the response is encoded as JSON by the first assertion.  - visit: \/api\/thing   request:   headers:     accept: application\/json   find:     - why: Assert accept header used by the server to serialize the request.       contains: '{\"bar\":\"baz\"}'     - path: foo.bar       is: baz   Array Values  You can use contains and count against arrays.  Given this response:  Content-type: text\/yml  items:   - apple   - banana   - chocolate title: Foods   ... this test can be used.  - visit: \/api\/thing   request:     headers:       accept: text\/yaml   find:     - path: items       count: 3     - path: items       count: \"&gt;1\"     - path: items       contains: chocolate     - path: items       not contains: lettuce     - path: items.1       is: banana   To select the root node use an empty string for path...  - visit: \/api\/thing   request:     headers:       accept: text\/yaml   find:     - path: \"\"       count: 2   Capturing Values  It can be handy to store the value for use in a subsequent test.  - visit: \/api\/thing.json   find:     - path: foo.bar       is: baz       set: fooBar  - visit: \/api\/thing.xml   find:     - why: Assert both JSON and XML ship the same value.       path: foo.bar       is: ${fooBar}   Example Tests  -   why: Assert we can count the root data.   visit: \/test_subject.php?op=root   find:     -       why: Using an empty string, may be more intuitive for some.       path: \"\"       count: 5  -   why: Assert we can store the ID of a REST response resource to use later   visit: \/test_subject.php?op=rest   find:     -       path: 0       count: 1     -       path: 0.id       is: 144       set: resourceId     -       path: 0.title       set: resourceTitle  -   why: Assert we can delete the resource by ID stored in previous test.   visit: \/test_subject.php?op=rest&amp;id=${resourceId}   request:     method: delete   expect: 204  -   visit: \/test_subject.php?op=items   request:     method: get     headers:       accept: text\/yaml   find:     -       path: items       count: 5     -       path: items       count: \"&gt;1\"     -       path: items       contains: apple     -       path: items       not contains: fish     -       path: items.1       is: banana     -       why: Use count 0 to detect non-existent index.       path: items.99       count: 0  -   visit: \/test_subject.php   request:     method: GET     headers:       accept: application\/json   find:     -       why: Assert accept header is applied by matching JSON.       contains: '{\"bar\":\"baz\"}'     -       path: foo       count: 1     -       path: foo.bar       is: baz     -       path: foo.bar       is not: yaz     -       path: foo.bar       contains: az     -       path: foo.bar       not contains: alpha     -       path: foo.bar       matches: \/^baz$\/     -       path: foo.bar       not matches: \/\\d+\/ -   visit: \/test_subject.php   request:     method: GET     headers:       accept: application\/json   find:     - '{\"bar\":\"baz\"}'     -       path: foo.bar       is: baz  -   visit: \/test_subject.php   request:     method: GET     headers:       accept: application\/xml   find:     - '&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;'     -       path: foo.bar       is: baz  -   visit: \/test_subject.php   request:     method: GET     headers:       accept: text\/yaml   find:     - 'bar: baz'     -       path: foo.bar       is: baz     Provided by the path plugin. ","tags":"","url":"demo--path.html"},{"title":"Making Requests Other Than GET","text":"  Automatic Body Encoding  When the body is not a scalar or null, it will be encoded based on the content type. The assumed content type is application\/octet-stream  Multiple Verbs  Use methods to request against the same endpoint using the same configuration, varying on method. This can be handly for testing REST APIs against 403 responses.  Notice how you can use ${request.method} to interpolate.  Custom Request Timeout This Test Only  You can set a custom timeout for this test only, which overrides request_timeout from the runner configuration.  -   why: Demonstrate custom request timeout for this test only.   visit: \/test_subject.php   request:     timeout: 33   Example Tests  -   why: Demonstrate custom request timeout for this test only.   visit: \/test_subject.php   request:     timeout: 120  -   why: Assert ${request.method} returns 405   visit: \/test_subject.php   request:     methods: [ PATCH, DELETE, HEAD, OPTIONS, TRACE ]   expect: 405  -   why: Assert request body interpolation is working as expected.   value: bar   set: fooValue  -   why: Assert post with content-type header and body works as expected.   visit: \/test_subject.php   request:     method: post     headers:       content-type: application\/json     body: '{\"foo\":\"${fooValue}\"}'   find:     - 'POST'     - 'content-type: application\/json'     - '{\"foo\":\"bar\"}'  -   why: Assert post encodes body object correctly.   visit: \/test_subject.php   request:     method: post     headers:       content-type: application\/json     body:       foo: bar   find:     - 'POST'     - 'content-type: application\/json'     - '{\"foo\":\"bar\"}'  -   visit: \/test_subject.php   request:     method: GET     body: 'lorem ipsum'   find:     - 'GET'     - 'lorem ipsum'  -   why: Assert put with multiple headers and body works as expected.   visit: \/test_subject.php   request:     method: PUT     headers:       content-type: application\/x-www-form-urlencoded       accept: application\/json, application\/xml     body: 'foo=bar&amp;do=re'   find:     - 'PUT'     - \"content-type: application\/x-www-form-urlencoded\"     - \"accept: application\/json, application\/xml\"     - 'foo=bar&amp;do=re'    Provided by the request plugin. ","tags":"","url":"demo--request.html"},{"title":"Sleep: Adding a Delay","text":"  sleep: &lt;seconds&gt; provides a means of adding a delay to the test runner.  Example Tests  -   visit: \/test_subject.php   find:     -       header: X-timestamp       set: time  -   why: Wait three seconds to ensure REQUEST_TIME increases.   sleep: 3  -   visit: \/test_subject.php   find:     -       header: X-timestamp       set: time2     -       eval: ${time2} &gt;= ${time} + 3    Provided by the sleep plugin. ","tags":"","url":"demo--sleep.html"},{"title":"Style Plugin: Assertions Against CSS","text":"  Assert a DOM element is visible  This example checks the CSS for both display and opacity properties to determine if the modal is visible based on CSS.  find:   -     dom: .modal     count: 1   -     dom: .modal     style: display     matches: \/^(?!none).+$\/   -     dom: .modal     style: opacity     is: 1   Example Tests  -   visit: \/test_subject.html   js: true   find:     -       dom: .visible       style: display       matches: \/^(?!none).+$\/       set: display     -       dom: .visible       style: display       not matches: \/^block$\/       set: display     -       dom: .visible       style: display       contains: inline     -       dom: .visible       style: display       not contains: flex     -       dom: .hidden-by-style       style: display       is: none     -       dom: .hidden-by-style       style: display       is not: hidden     -       dom: .hidden-by-class       style: display       is: none     Provided by the style plugin. ","tags":"","url":"demo--style.html"},{"title":"Value Plugin","text":"   Set variables from constant\/interpolated values. Assert against constant\/interpolated values. Works outside of HTTP requests.   The real benefit of this plugin comes when you use shorthand, mixins, or plugins to set variables in realtime, as it allows to you to assert against those dynamic values.  Example Tests  -   why: Demonstrate the Value Plugin syntax using \"why\".   value: lorem ipsum dolar   set: vars.string -   value: ${vars.string}   is: lorem ipsum dolar -   value: ${vars.string}   is not: foo bar -   value: ${vars.string}   contains: ipsum -   value: ${vars.string}   not contains: alpha -   value: ${vars.string}   matches: \/^lorem\/ -   value: ${vars.string}   not matches: \/\\d{3}\/ -   value: 123   set: vars.number -   value: ${vars.number}   is: 123 -   value: ${vars.number}   contains: 23 -   value: ${vars.number}   matches: \/\\d{3}\/  -   url: \/test_subject.html   find:     -       why: Assert we can perform an assertion \"set\".       value: Twilight       set: control     -       why: Assert we can interpolate on \"value\".       value: ${control}       set: control2  -   why: Assert set values persist to the next test.   url: \/test_subject.html   find:     -       dom: h1       is: ${control}     -       dom: h1       is: ${control2}    Provided by the value plugin. ","tags":"","url":"demo--value.html"},{"title":"Example Tests","text":"  -   visit: \/test_subject.html   find:     -       why: XPath can also be used to locate things, so if you want to be sure that the third .block-title is a given value, you should use xpath.       xpath: '(\/\/*[contains(@class, \"block-title\")])[3]'       text: Latest Blog Post     -       xpath: '(\/\/*[contains(@class, \"block-title\")])[3]'       is: Latest Blog Post     -       xpath: '(\/\/*[contains(@class, \"block-title\")])[3]'       is not: Blog Post     -       xpath: '(\/\/*[contains(@class, \"block-title\")])[3]'       contains: Blog Post     -       xpath: '(\/\/*[contains(@class, \"block-title\")])[3]'       matches: \/blog post\/i      Provided by the xpath plugin. ","tags":"","url":"demo--xpath.html"},{"title":"Developers Note: User Messages","text":"  When working on this project, never echo directly.  Extension Authors  For messages related to a test, you must use $test-&gt;addMessage(... because the timing of the output will be handled by the runner. You must not use a printer from within plugins or custom extensions!  In some cases you may want to display your messages sooner than later, if so you may call $test-&gt;echoMessages(). Not this will print all test messages, including those set so far in the processing.  This ensures FIFO.  Core Authors  Follow the code as shown below for user feedback. The instance of \\AKlump\\Messaging\\MessengerInterface will determine how the messages are printed, you just worry about the message, level, and verbosity as you write code.  \/\/ INFO MESSAGE $printer-&gt;deliver(new Message(   [     'This is a two-line\",     \"info message.',   ], ));  \/\/ NOTICE MESSAGE $printer-&gt;deliver(new Message(   [     'This is an notice.',     '',   ],   \\AKlump\\Messaging\\MessageType::SUCCESS, ));  \/\/ ERROR MESSAGE $printer-&gt;deliver(new Message(   [     'This is an error message with an extra line break.',     '',   ],   \\AKlump\\Messaging\\MessageType::ERROR, ));   \/\/ VERBOSE, INFO $printer-&gt;deliver(new Message(   [     'This is a debug message that will show with (A)ny verbosity.',   ],   \\AKlump\\Messaging\\MessageType::DEBUG,   new \\AKlump\\CheckPages\\Output\\VerboseDirective('D') ));  \/\/ or it's shorthand... $printer-&gt;deliver(new \\AKlump\\CheckPages\\Output\\DebugMessage(   [      'Demo debug message',      '',     'This is a debug message that will show with (A)ny verbosity.',   ], ));   You will need an instance of \\AKlump\\Messaging\\MessengerInterface, e.g.,  $printer = new \\AKlump\\CheckPages\\Output\\ConsoleEchoPrinter($runner-&gt;getOutput());  ","tags":"","url":"dev--output.html"},{"title":"Options: Configurable Abstraction","text":"  @todo This needs to be rethought, now that we have shorthand.  How it Looks  # file: suite.yml -   my_custom_option: 123      Options are a step up from imports because they allow you to consolidate reusable code, while offering configuration via arguments, like a function. They are \"options with arguments\".   Explained  If you need to do some fancy PHP transformations at certain points of test execution, you can hook into that flow using one or more custom test options.  These are nothing more than functions attached to events. In the following example, foo is the custom test option under study.  # file: suite.yml -   visit: \/index.html   foo: 123   find:     -       dom: h1       is: Hello World!   The add_test_option() function allows you to add customization at the level of your runner file.  # file: runner.php add_test_option('foo', [   'onBeforeTest' =&gt; function ($option, \\AKlump\\CheckPages\\Parts\\Test $test, $context){     \/\/ Note, $option === 123   }, ]);   The first argument defines the option as it will be used in the suite file, e.g., foo. The second argument is an array of callbacks, keyed by one or more of these methods:   onLoadSuite(SuiteEventInterface $event, array $context) onBeforeTest($option, TestEventInterface $event, array $context) onBeforeDriver($option, TestEventInterface $event, array $context) onBeforeRequest($option, DriverEventInterface $event, array $context) onBeforeAssert($option, AssertEventInterface $event, array $context) onAssertToString($option, string $stringified, \\AKlump\\CheckPages\\Assert $assert, array $context)   These examples show how $option can have non-scalar values.  -   bar:     - do     - re     - mi   baz:     lorem: ipsum dolar   add_test_option('bar', [   'onBeforeTest' =&gt; function ($option, \\AKlump\\CheckPages\\Parts\\Test $test, $context){     list($do, $re, $mi) = $option;     \/\/ ...   },   'onBeforeRequest' =&gt; function ($option, &amp;$driver, array $context){     list($do, $re, $mi) = $option;     \/\/ ...   }, ]);  add_test_option('baz', [   'onBeforeTest' =&gt; function ($option, \\AKlump\\CheckPages\\Parts\\Test $test, $context){     if ($option['lorem'] === 'ipsum dolar') {       \/\/ ...     }   }, ]);  run_suite('*');   onBeforeTest  The onBeforeTest callback is the best place to put custom processing if you want to hijack a \"test\". For example you could use it to set a bunch of custom variables. It's not a test, but a processor, in such a case.  Advance to Next Test  In some cases you may want to advance to the next test after you finish executing some code inside of onBeforeTest in your custom test option. That is to say, you want to mark the test (option) as complete and stop any further execution on that test config. To do this you should return the value \\AKlump\\CheckPages\\Parts\\Test::IS_COMPLETE. This will mark the test neither passed nor failed, rather it will silently move on.  add_test_option('event.create', [   \"onBeforeTest\" =&gt; function ($option, \\AKlump\\CheckPages\\Parts\\Test $test, array $context) {      \/\/ ...      return \\AKlump\\CheckPages\\Parts\\Test::IS_COMPLETE;   }, ]);  ","tags":"","url":"ext--add_test_option.html"},{"title":"Event Responders","text":"  To see all events look to \\AKlump\\CheckPages\\Event.  Writing a Dynamic Import  In this example a \"shorthand\" is built that can expand to multiple tests.  respond_to(\\AKlump\\CheckPages\\Event::SUITE_LOADED, function (\\AKlump\\CheckPages\\Event\\SuiteEventInterface $event) {   $suite = $event-&gt;getSuite();   foreach ($suite-&gt;getTests() as $test) {     $config = $test-&gt;getConfig();      \/\/ Look for the shorthand: \"http.methods_not_allowed\".  Remember this runs     \/\/ before the configuration is validated, so shorthand is free to take any     \/\/ form, and doesn't have to match the schema.     if (isset($config['http']['methods_not_allowed'])) {         \/\/ Now that we've found it, we will replace the \"test\" with the multiple       \/\/ tests that we generate in array_map().       $suite-&gt;replaceTestWithMultiple($test, array_map(function ($method) use ($config) {          \/\/ This is a single, expanded-from-shorthand test configuration.         return [           'why' =&gt; sprintf('Assert %s returns 405: Method Not Allowed', $method),           'url' =&gt; $config['url'],           'request' =&gt; ['method' =&gt; $method],           'expect' =&gt; 405,         ];       }, $config['http']['methods_not_allowed']));     }   } });  ","tags":"","url":"ext--event-responders.html"},{"title":"Imports: Static Abstraction","text":"  See plugin page. ","tags":"","url":"ext--imports.html"},{"title":"Mixins: Shared Code Between Runners","text":"  How it Looks  # file: runner.php add_mixin('my_custom_mixin');      When you want to share code across runners, you should look to mixins. Often you will want to put your runner function implementations inside a mixin file.   Explained  Another way to extend Check Pages is to use the add_mixin() function. This method is easier and faster than writing a plugin. It is a simple means to share runner customisation across different runners, or even projects. This is the basis for the authentication providers shipped with Check Pages.  . \u2514\u2500\u2500 cp_tests     \u251c\u2500\u2500 mixins     \u2502   \u2514\u2500\u2500 foo.php     \u251c\u2500\u2500 runner.php     \u2514\u2500\u2500 suite.yml    Create a directory to contain one or more mixin files. This can be located within any resolvable directory. (See \\AKlump\\CheckPages\\Parts\\Runner::resolve.) In that directory create a file, whose filename will be used as the first argument to add_mixin()--the mixin \"name\". So for add_mixin('mixins\/foo') you should create mixins\/foo.php as shown in the diagram above. In the runner file, make reference to the mixin, passing the configuration as expected by the mixin.  # file: runner.php  add_mixin('mixins\/foo', [   \"title\" =&gt; \"Lorem\",   \"color\" =&gt; \"blue\", ]); ...  The second argument, the configuration, is available in the mixin file, mixins\/foo.php as $config.  # file: mixins\/foo.php  $title = $config['title']; $color = $config['color'];   The runner instance \\AKlump\\CheckPages\\Parts\\Runner is available as $runner. You may use any of the runner_functions.inc as you might otherwise do in a runner file. By convention, you may create an class named for the mixin in your file if necessary. You should add the namespace AKlump\\CheckPages\\Mixins to your mixin file.   Output  You may write output if desired, for example:  echo sprintf('Base URL is %s', config_get('base_url')) . PHP_EOL; echo \\AKlump\\LoftLib\\Bash\\Color::wrap('blue', 'foo');   Namespace  You should use the namespace AKlump\\CheckPages\\Mixins for any class objects you might create.  Errors  To stop testing immediately you should throw an instance of \\AKlump\\CheckPages\\Exceptions\\StopRunnerException. The message argument will be displayed to the user. ","tags":"","url":"ext--mixins.html"},{"title":"Plugins: Full Customization","text":"  How it Looks  How it looks is myriad and you must refer to the plugin code to determine how it's implemented when writing tests.  Explained  This is the most involved method of extending Check Pages, and offers the greatest control as well.  @todo Where do I put these as an end user?  Creating a Plugin   Create a unique folder in plugins with the following structure. In this example the new plugin will be called foo_bar.  plugins \u2514\u2500\u2500 foo_bar    \u251c\u2500\u2500 compile.php    \u251c\u2500\u2500 FooBar.php    \u251c\u2500\u2500 README.md    \u251c\u2500\u2500 schema.definitions.json    \u251c\u2500\u2500 schema.assertion.json    \u251c\u2500\u2500 schema.test.json    \u251c\u2500\u2500 suite.yml    \u2514\u2500\u2500 test_subject.html  Write the suite.yml file which will be run against test_subject.html, test_subject.php, test_subject.json, etc Create test_subject.html or test_subject.php as needed to test _ suite.yml_. README.md is optional, but will be added to the Check Pages documentation when it's compiled and should be used to give examples of how the plugin should be implemented.   Extending the JSON Schema for Suite Validation  The plugin may provide schema with any of the following files:   my_plugin\/schema.definitions.json my_plugin\/schema.test.json my_plugin\/schema.assertion.json   (Inspect plugins to see how these are used. Be aware that some properties are reserved and added automatically, i.e., why, extra; you should not add these in your plugin. Here are some examples.)  # file: schema.assertion.json   {     \"type\": \"object\",     \"required\": [         \"foo\"     ],     \"properties\": {         \"foo\": {             \"$ref\": \"#\/definitions\/dom_dom\"         }     },     \"additionalProperties\": false }   # file: schema.assertion.json   {     \"js_eval\": {         \"type\": \"string\",         \"pattern\": \".+\",         \"examples\": [             \"location.hash\"         ]     } }   Advanced  The json_schema plugin is a good example of a plugin that totally handles the assertion on it's own. You may want to study that if you need to do something fancy.  You can see the basic strategy here:   You may only return TRUE, indicating the assertion passed. If it failed you must throw an exception, the message of which will be printed in the test results as to the reason for the failure.   public function onBeforeAssert(\\AKlump\\CheckPages\\Event\\AssertEventInterface $event) {     $assert = $event-&gt;getAssert();     $response = $event-&gt;getReponse();    $assert-&gt;setAssertion(Assert::ASSERT_CALLABLE, function ($assert) {      \/\/ ... do your fancy assertion      if ($it_failed) {       throw new \\RuntimeException(sprintf('The reason for the failure'));     }      return TRUE;   }); }   Testing Plugins  To run a plugin's tests do this: .\/bin\/run_plugin_tests &lt;plugin&gt;.  (Don't forget to bump build plugins if you make a change.)  Compiled Files  Do not edit the following, as they are created in the build step and will be overwritten. To affect these files you need to look to plugins\/ directory, which contains the source code.  . \u251c\u2500\u2500 tests \u2502     \u251c\u2500\u2500 plugins \u2502     \u2502     \u251c\u2500\u2500 foo.yml \u2502     \u2502     \u2514\u2500\u2500 javascript.yml \u2502     \u251c\u2500\u2500 runner_plugins.php \u2514\u2500\u2500 web     \u2514\u2500\u2500 plugins         \u251c\u2500\u2500 foo.html         \u2514\u2500\u2500 javascript.html    Unique Compilation  If your plugin needs to do something unique during compilation, such as provide extra files, it can implement compile.php. Here's an example from the imports plugin.  # file: imports\/compile.php  \/**  * @file Copy over the imports files during compile.  *\/  $source = \"$plugin_dir\/imports\"; $destination = \"$compile_dir\/tests\/imports\";  if (!is_dir($destination)) {   mkdir($destination, 0777, TRUE); } copy(\"$source\/_headings.yml\", \"$destination\/_headings.yml\"); copy(\"$source\/_links.yml\", \"$destination\/_links.yml\");  foreach ([            \"$destination\/_headings.yml\",            \"$destination\/_links.yml\",          ] as $path) {   if (!file_exists($path)) {     return FALSE;   }   $data = file_get_contents($path);   $data = str_replace('test_subject', $plugin['id'], $data);   if (!file_put_contents($path, $data)) {     return FALSE;   } }  ","tags":"","url":"ext--plugins.html"},{"title":"Shorthand: Simpler, Cleaner, and More Readable","text":"  How it Looks  # file: suite.yaml -   user: foo_user   item.delete: 123      Shorthand is a way to simplify the reading and writing of your tests.   Explained  Without the custom shorthand, the above would have been written like this:  # file: suite.yaml  -   user: foo_user   url: \/api\/items   request:     method: delete     body: \"{id:123}\"   find:     -       path: result       is: deleted   However, by adding item.delete using add_shorthand(), we get the ability to write less code, which is less error-prone, and faster to reason about.  Here's the runner implementation:  # file: runner.php  add_shorthand('item.delete', function ($shorthand, $test) {   assert(is_numeric($shorthand));   $config = $test-&gt;getConfig();   $config['url'] = '\/api\/items';   $config['request'] = [     'method' =&gt; 'delete',     'body' =&gt; json_encode([       'id' =&gt; $shorthand     ]),   ];   $config['find'] = $config['find'] ?? [];   $config['find'][] = [     'path' =&gt; 'result',     'is' =&gt; 'deleted',   ];   $test-&gt;setConfig($config); });   An Example with Multiple Replacement Tests  add_shorthand('json_factory', function ($shorthand, \\AKlump\\CheckPages\\Parts\\Test $test) use ($runner) {   assert(is_array($shorthand));   $config = $test-&gt;getConfig();   $path = $runner-&gt;resolveFile($shorthand['schema']);   $faker = new Faker($path);   $data = $faker-&gt;jsonSerialize();    foreach (($shorthand['values'] ?? []) as $key =&gt; $value) {     $data[$key] = $value;   }    $config['is'] = json_encode($data);    $test_configs = [];   $test_configs[] = $config;   $test_configs[] = [     'set' =&gt; $config['set'] . '.validationSchema',     'is' =&gt; json_encode($faker-&gt;getValidationSchema()),   ];   $test-&gt;getSuite()-&gt;replaceTestWithMultiple($test, $test_configs); });   Preserve $shorthand for Later  Follow this strategy if you need to keep the value of $shorthand in the test, for other event handlers or later processing of some sort. See Stash for more info.  # file: runner.php  add_shorthand('foo', function ($shorthand, $test) {   $config = $test-&gt;getConfig();   $config['extras']['foo'] = $shorthand;   $test-&gt;setConfig($config); });  ","tags":"","url":"ext--shorthand.html"},{"title":"Code Snippets","text":"  This page will list out some example code you might use while extending.  Http Request  This example shows how to make a request from the body of a Shorthand.  add_shorthand('bundle_access', function ($shorthand, \\AKlump\\CheckPages\\Parts\\Test $test) {   $url = $test-&gt;getSuite()-&gt;getRunner()-&gt;url('\/foo\/bar');   $guzzle = new \\AKlump\\CheckPages\\GuzzleDriver();   $response = $guzzle-&gt;getClient()-&gt;get($url);   $data = json_decode($response-&gt;getBody(), TRUE)['data']; });  ","tags":"","url":"ext--snippets.html"},{"title":"File Output","text":"  File output is enabled in the runner configuration file. Two things are required to enable this feature:   An existing, writeable directory An entry in the runner config with the location of the directory as a resolvable path.   files: files\/dev   Once you have this enabled, plugins may make use of this for file output during testing.  Core Usage   Each suite will create a subdirectory by it's filename. In that directory the following files will be created:   urls.txt a list of urls that failed testing. failures.txt verbose output of the failures only.    Try using tail -f files\/SUITE\/urls.txt during development.  Browser Session Storage  Authentication can slow down your tests. To mitigate this you can create a writeable folder at {config.files}\/storage and the session cookies will be written to disk the first time they are obtained from the test subject. After that, authentication will skip the login step and pull the session data from files\/storage. Protect the contents of that directory because it contains credentials.  If you do not want this feature, then make sure that there is no directory called storage in the the directory you've defined as your writeable files in the runner config. ","tags":"","url":"file_output.html"},{"title":"Testing Forms","text":"  Drupal 8  The following is how you can test the contact form:  -   why: Gather form info for next test.   visit: \/contact   find:     -       why: Capture form build ID to use in next POST test.       dom: '.contact-form [name=\"form_build_id\"]'       attribute: value       set: formBuildId     -       why: Capture form ID to use in next POST test.       dom: '.contact-form [name=\"form_id\"]'       attribute: value       set: formId     -       why: Capture submit button value to use in next POST test.       dom: '.contact-form [name=\"op\"]'       attribute: value       set: op     -       why: Capture honeypot_time to use in next POST test.       dom: '.contact-form [name=\"honeypot_time\"]'       attribute: value       set: honeypotTime  -   why: Prevent honeypot module from invalidating submission.   sleep: 3  -   why: Assert contact form stays on \/contact after successful submission.   visit: \/contact   request:     method: POST     headers:       Content-Type: application\/x-www-form-urlencoded     body: form_id=${formId}&amp;form_build_id=${formBuildId}&amp;op=${op}&amp;honeypot_time=${honeypotTime}&amp;name=Alpha&amp;mail=alpha@foo.com&amp;message[0][value]=lorem%20ipsum   find:     -       dom: 'meta[property=\"og:url\"]'       attribute: content       matches: \/\\\/contact$\/     -       why: Assert no form messages were triggered.       dom: .message[data-level=\"error\"]       count: 0    Proposed Shorthand  Not yet developed.  -   url: \/contact   form:     -       name: name       value: Alpha     -       name: mail       value: alpha@foo.com     -       name: message[0][value]       value: lorem ipsum  ","tags":"","url":"forms--drupal.html"},{"title":"Suite Groups","text":"  It may be helpful to combine suites into groups.  This is done by placing one or more suites into a folder. The name of the folder containing the suites is the group ID.  That's it.  You can use the --group=&lt;GROUP_ID&gt; to filter by group.  Given this example structure...  . \u2514\u2500\u2500 suites     \u251c\u2500\u2500 admin     \u2502\u00a0\u00a0 \u2514\u2500\u2500 status.yml     \u2502\u00a0\u00a0 \u251c\u2500\u2500 scenario1.yml     \u251c\u2500\u2500 api     \u2502\u00a0\u00a0 \u251c\u2500\u2500 crud.yml     \u2502\u00a0\u00a0 \u251c\u2500\u2500 scenario1.yml     \u2502\u00a0\u00a0 \u2514\u2500\u2500 scenario2.yml     \u2514\u2500\u2500 web_ui         \u251c\u2500\u2500 contact.yml         \u251c\u2500\u2500 footer.yml         \u2514\u2500\u2500 homepage.yml   Setup the runner like this:  &lt;?php add_directory(__DIR__ . '\/suites'); run_suite('admin\/*'); run_suite('api\/*'); run_suite('web_ui\/*');   You are able to use these CLI arguments:  --group=admin --group=api  # As well as via alias... -g web_ui   Notice that two groups (admin, api) have scenarios with the same name (scenario1.yml). This is possible, but would require the use of both --group and --filter to run only one, as you might conclude:  run runner.php -g admin -f scenario1  ","tags":"","url":"grouping.html"},{"title":"Interpolation","text":"  Rules for Test Interpolation   The timing of interpolation can be tricky. Since only plugins know what test keys they provide, they MUST handle interpolation on their own test keys. You should set variables on the test, which will persist only for that test. \\AKlump\\CheckPages\\Parts\\Test::variables() You should set variables on suite, which will persist across tests. \\AKlump\\CheckPages\\Parts\\Suite::variables You may also want to use a throw-away instance such as is done in \\AKlump\\CheckPages\\Plugin\\LoopCurrentLoop::execute When a plugin interpolates test config, it should probably set the config so that the interpolated values are passed down the execution chain, e.g. taken from the Request plugin:  function (TestEventInterface $event) {   $test = $event-&gt;getTest();   $this-&gt;config = $test-&gt;getConfig();   $test-&gt;interpolate($this-&gt;config['request']);   $test-&gt;setConfig($this-&gt;config); }      Example Implementations   \\AKlump\\CheckPages\\Plugin\\Value \\AKlump\\CheckPages\\Plugin\\Request   Provide Variables from Configuration Files  You may set (global) variables in configuration, which may be interpolated by all suites and tests, by using the variables root-level key, like this:  variables:   foo_name: bar_value  ","tags":"","url":"interpolation.html"},{"title":"PhpStorm Integration","text":"  You may use the phpstorm.http mixin to export test suites as HTTP Client files.  To enable this add the following to your runner:  add_mixin('phpstorm.http', [   'output' =&gt; config_get('files') . '\/phpstorm',   'single_file' =&gt; TRUE,   'exclude_passing' =&gt; TRUE, ]);    As you can see you have to create an output directory as output. Each suite will create it's own file unless you set single_file to TRUE. Set exclude_passing and only failing tests will be exported.   Each time your run the suite, the file will be recreated.  Be careful with these files because they contain session cookies for any authenticated requests. ","tags":"","url":"phpstorm.html"},{"title":"Continuing and Retesting","text":"  These features only work when file storage is enabled.  The Continue Option  If you have lots of suites, and you happen to interrupt the runner after you've completed a portion, you may want to continue, rather than start over. This sets up the scenario where you will use the --continue option.  It works by skipping all the suites before the one that was interrupted, and beings with that suite's first test. It means some of the tests in the suite will be repeated, that is, it doesn't continue with the last test, but the last suite.  The Retest Option  If you have just run a bunch of suites, and had only a few failures, which you think you've fixed, you will want to use the --retest option.  This works by re-running any suite, which had one or more test failures. Yes, the entire suite is retested, not just the failing test in the suite. ","tags":"","url":"retest.html"},{"title":"Search Results","text":" ","tags":"","url":"search--results.html"},{"title":"Service Classes","text":"  Event Subscribers   Create a service class that implements \\Symfony\\Component\\EventDispatcher\\EventSubscriberInterface Add it to services.yml; tag it with { name: event_subscriber } See the continue service for an example.  ","tags":"","url":"services.html"},{"title":"Stashing Values","text":"  There is a special map key extras available on every test, which is ignored by the schema validator and can be used to stash\/retrieve arbitrary data by plugins and extension strategies throughout the testing process (and across event handlers).  The following example is taken from a mixin that had to move it's shorthand config to the stash and then act upon those values just before the request. You can see how extras is used to achieve this.  It's probably not a good idea to use the extras key directly when writing tests, as this is may not feel as clean or clear. Better to use add_shorthand as shown below.  This is how the test is written.  -   why: 'Assert device d0 returns per schema.'   url: \/api\/2.0\/rest\/devices\/d0   query_auth:     count: 3   add_shorthand('query_auth', function ($shorthand, \\AKlump\\CheckPages\\Parts\\Test $test) use ($mixin_config) {   $test_config = $test-&gt;getConfig();   $test_config['extras']['query_auth'] = $shorthand + $mixin_config;   $test-&gt;setConfig($test_config); });   Now the test has this structure, which will pass validation, yet still holds the data for retrieval.  -   why: 'Assert device d0 returns per schema.'   url: \/api\/2.0\/rest\/devices\/d0   extras:     query_auth:       count: 3   $dispatcher = $runner-&gt;getDispatcher(); $dispatcher-&gt;addListener(\\AKlump\\CheckPages\\Event::REQUEST_CREATED, function (\\AKlump\\CheckPages\\Event\\DriverEventInterface $event) {   $test_config = $event-&gt;getTest()-&gt;getConfig();   if (!empty($test_config['extras']['query_auth'])) {     query_auth_calculate($test_config, $event-&gt;getTest());   } });   ","tags":"","url":"stash.html"},{"title":"Using <code>why<\/code> For Better Clarity","text":"  The test suite output will automatically generate a line for each assertion, which in many cases is sufficient for test readability. However you may use the why key in your tests if you wish. This serves two purposes, it makes the tests more clear and readable, and it makes the test output more understandable, and especially if you're trying to troubleshoot a failed assertion.  At the Test Level  You may attach why to a test, like this...  -   why: Assert homepage has lorem text.   url: \/index.php   find:     - Lorem ipsum.   \u23f1  RUNNING \"SUITE\" SUITE... \ud83d\udd0e Assert homepage has lorem text. \ud83d\udc4d http:\/\/localhost:8000\/index.php \u251c\u2500\u2500 HTTP 200 \u251c\u2500\u2500 Find \"Lorem ipsum\" on the page. \u2514\u2500\u2500 Test passed.   At the Assert Level  ... or to any assertion, like this:  -   url: \/index.php   find:     -       dom: h1       why: Assert page title is lorem text.       text: Lorem ipsum   \u23f1  RUNNING \"SUITE\" SUITE... \ud83d\udc4d http:\/\/localhost:8000\/index.php \u251c\u2500\u2500 HTTP 200 \u251c\u2500\u2500 Assert page title is lorem text. \u2514\u2500\u2500 Test passed.  ","tags":"","url":"why.html"},{"title":"Debugging While Running Tests","text":"  XDebug 3  https:\/\/xdebug.org\/docs\/all_settings#discover_client_host  From your logs: 192.168.50.1 (your physical machine IP, where PhpStorm is running -- as seen from VM) vs 127.0.0.1 (your local VM). P.S. You should have mentioned that it's an remote debug \/ running on VM. For local it would have made no difference but for remote  Checklist   Execute lyb Make sure xdebug_disable_from_host is not activated in bin\/run_check_pages. Make sure PhpStorm is listening. Check the Xdebug settings to match: xdebug.client_host = host.docker.internal xdebug.start_with_request = yes xdebug.discover_client_host = true  ","tags":"","url":"xdebug.html"}]};
