<?php

namespace AKlump\CheckPages\Plugin;

use AKlump\LoftLib\Code\Strings;
use Symfony\Component\Yaml\Yaml;

final class PluginsCompiler {

  /**
   * @var string
   */
  private $masterSchemaPath;

  /**
   * @var \AKlump\CheckPages\Plugin\PluginsManager
   */
  private $pluginsManager;

  /**
   * @var array
   */
  private $schema;

  /**
   * @var string
   */
  private $examplesPath;

  /**
   * @var string
   */
  private $generatedSchemaPath;

  /**
   * PluginsCompiler constructor.
   *
   * @param string $plugins_dir
   * @param string $master_schema_path
   *   The path to the base schema to load as the template; plugins are merged
   *   into this.  This schema is what is editable by developers.
   * @param string $generated_schema_path
   *   The output schema path, with plugins compiled in.
   * @param string $examples_path
   *   The path to the projects demo/example files.
   */
  public function __construct(
    PluginsManager $plugins_manager,
    string $master_schema_path,
    string $generated_schema_path,
    string $examples_path
  ) {
    $this->pluginsManager = $plugins_manager;

    $this->masterSchemaPath = $master_schema_path;
    $this->schema = ['readyOnly' => TRUE] + $this->loadJson($master_schema_path);
    $description = $this->schema['description'] ?? '';
    $description .= '  DO NOT EDIT THIS FILE.  AUTO-GENERATED FROM ' . basename($master_schema_path);
    $this->schema = array_filter([
        '$schema' => $this->schema['$schema'] ?? NULL,
        'title' => $this->schema['title'] ?? NULL,
        'description' => trim($description),
      ]) + $this->schema;

    $this->generatedSchemaPath = $generated_schema_path;
    $this->examplesPath = $examples_path;
  }

  /**
   * Compile all plugins into the app.
   */
  public function compile() {
    $plugins = $this->pluginsManager->getAllPlugins();
    foreach ($plugins as &$plugin) {
      $this->compilePlugin($plugin);
      if (file_exists($plugin['path'] . '/compile.php')) {
        $plugin_dir = $plugin['path'];
        $compile_dir = $this->examplesPath;
        $result = require $plugin['path'] . '/compile.php';
        if (!$result) {
          throw new \RuntimeException(sprintf("Compilation failed in %s.", $plugin['path'] . '/compile.php'));
        }
      }
    }
    $this->createTestRunnerPhpFile($plugins);
  }

  private function createTestRunnerPhpFile($plugins) {
    $runner_code = [
      '<?php',
      "/** AUTOGENERATED DO NOT EDIT */",
      "add_directory(__DIR__ . '/plugins');",
      "load_config('config/local');",
    ];

    foreach ($plugins as $plugin) {
      if ($plugin['has_tests']) {
        $runner_code[] = "run_suite('{$plugin['id']}');";
      }
    }
    $runner_file_path = $this->examplesPath . '/tests/runner_plugins.php';
    $result = file_put_contents($runner_file_path, implode(PHP_EOL, $runner_code));
    if (!$result) {
      throw new \RuntimeException(sprintf('Cannot create runner file: %s', $runner_file_path));
    }
  }

  /**
   * Compile the plugin schema file.
   *
   * @param string $id
   *   The plugin ID.
   * @param string $path_to_plugin
   *   The filepath to the plugin definition directory.
   */
  private function compilePlugin(array &$plugin) {
    $this->compilePluginSchema($plugin['id'], $plugin['path']);
    $plugin['has_tests'] = $this->handleTests($plugin['id'], $plugin['path']);
  }

  private function ensureDir($filepath) {
    if (!is_dir($filepath)) {
      mkdir($filepath, 0755, TRUE);
    }
  }

  /**
   * Compile the plugin schema file.
   *
   * @param string $id
   *   The plugin ID.
   * @param string $path_to_plugin
   *   The filepath to the plugin definition directory.
   */
  private function handleTests(string $id, string $path_to_plugin) {
    $this->ensureDir($this->examplesPath . "/tests/plugins/");
    $this->ensureDir($this->examplesPath . "/web/plugins/");

    // Locate the file with the filename of 'test_subject'.
    $subject = array_values(array_filter(scandir($path_to_plugin), function ($path) {
        return pathinfo($path, PATHINFO_FILENAME) === 'test_subject';
      }))[0] ?? NULL;
    if (empty($subject)) {
      return FALSE;
    }
    $extension = pathinfo($subject, PATHINFO_EXTENSION);
    $suite_relative_path_final = "plugins/$id.$extension";
    copy("$path_to_plugin/$subject", $this->examplesPath . "/web/${suite_relative_path_final}");

    // The test suite.
    $plugin_suite = Yaml::parseFile($path_to_plugin . '/suite.yml');
    $plugin_suite = array_map(function (array $test) use ($subject, $suite_relative_path_final) {
      if (array_key_exists('visit', $test)) {
        $test['visit'] = str_replace($subject, $suite_relative_path_final, $test['visit']);
      }
      if (array_key_exists('url', $test)) {
        $test['url'] = str_replace($subject, $suite_relative_path_final, $test['url']);
      }

      return $test;
    }, $plugin_suite);
    file_put_contents($this->examplesPath . "/tests/plugins/{$id}.yml", Yaml::dump($plugin_suite, 6));

    return TRUE;
  }

  /**
   * Compile the plugin schema file.
   *
   * @param string $id
   *   The plugin ID.
   * @param string $path_to_plugin
   *   The filepath to the plugin definition directory.
   */
  private function compilePluginSchema(string $id, string $path_to_plugin) {
    if (isset($this->schema['definitions'][$id])) {
      throw new \RuntimeException(sprintf('Plugin ID conflict; %s.definitions.%s already exists', basename($this->masterSchemaPath), $id));
    }

    $before = md5(json_encode($this->schema));

    // The plugin MAY provide new #definitions.
    $plugin_definitions_schema = $path_to_plugin . '/schema.definitions.json';
    if (file_exists($plugin_definitions_schema)) {
      $to_merge = $this->loadJson($plugin_definitions_schema);
      $conflicting_keys = array_intersect_key($this->schema['definitions'], $to_merge);
      if ($conflicting_keys) {
        throw new \RuntimeException(sprintf('The following definitions exist in the master schema and cannot be added by the plugin %s: %s', $id, implode(', ', $conflicting_keys)));
      }
      $this->schema['definitions'] += $to_merge;
    }
    // The plugin MAY provide test-level definitions.
    $plugin_test_schema = $path_to_plugin . '/schema.test.json';
    if (file_exists($plugin_test_schema)) {
      $to_merge = $this->loadJson($plugin_test_schema);
      $this->schema["items"]["anyOf"][] = $to_merge;
    }

    // The plugin must provide the find schema.
    $plugin_find_schema = $path_to_plugin . '/schema.find.json';
    if (file_exists($plugin_find_schema)) {
      $this->schema['definitions'][$id] = [
        'title' => Strings::title("$id Plugin Assertion"),
      ];
      $schema_find = $this->loadJson($plugin_find_schema);

      // This property should be present for all plugins, however a plugin can
      // set this to false if it wants to block it.
      if (empty($schema_find['properties']['why']) || FALSE !== $schema_find['properties']['why']) {
        $schema_find['properties']['why'] = [
          '$ref' => '#/definitions/why',
        ];
      }

      $this->schema['definitions'][$id] += $schema_find;
      $this->schema['definitions']['find']['oneOf'][1]['items']['oneOf'][] = [
        '$ref' => "#/definitions/{$id}",
      ];
    }

    if ($before !== md5(json_encode($this->schema))) {
      $this->saveJson($this->generatedSchemaPath, $this->schema);
    }

    // Update the schema in the plugins manager.
    $this->pluginsManager->setSchema($this->loadJson($this->generatedSchemaPath));
  }

  private function loadJson(string $filepath): array {
    $data = json_decode(file_get_contents($filepath), TRUE);
    if (is_null($data)) {
      throw new \RuntimeException(sprintf('Invalid JSON in %s', $filepath));
    }

    return $data;
  }

  private function saveJson($filepath, $data) {
    $result = file_put_contents($filepath, json_encode($data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
    if (!$result) {
      throw new \RuntimeException(sprintf('Could not save %s', $filepath));
    }

    return $this;
  }

}
